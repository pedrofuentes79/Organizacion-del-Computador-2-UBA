Ejercicio Lista Enlazada:

2. Si dentro de una función cualquiera, creamos una lista haciendo lista_t* mi_lista = nueva_lista();, y luego otra haciendo lista_t mi_otra_lista; 
¿en que segmentos de memoria se alojan las siguientes variables?:

a: mi_lista se va a alojar en el segmento HEAP, pues corresponde a una variable dinamica administrada por malloc.
De todos modos, su puntero se va a alojar en el stack, pues es una variable local dentro de una funcion.

b: mi_otra_lista es simplemente la declaracion de la variable, entonces se va a alojar en el stack, pues aun no se le aloco memoria.

c: mi_otra_lista.head tambien esta en el stack, pues es un campo de mi_otra_lista, que tambien esta en el stack.

d: mi_lista->head tambien esta en el HEAP, pues es un campo de un struct que esta en el HEAP.

Si a mi_otra_lista la creamos fuera de cualquier funcion, va a ir al segmento BSS, donde van las variables globales no inicializadas.

Ejercicio Classify Chars
1. En C, no hace falta declarar el tamaño de un string ya que se representan como arreglos de chars, y el char '\0' es el que determina cuando finaliza el string
2. Elegimos dos opciones; devolver un struct y devolver punteros a arreglos.
En la version classify_chars_v2 hicimos que la funcion reciba punteros a arreglos, y que modifique esos arreglos, siendo esos los parametros de salida.
En la version classify_chars_v3 hicimos que la funcion reciba solamente el string, y que inicialize un arreglo de structs, siendo cada struct el resultado de cada string, respectivamente.
De este modo, hacemos que cada struct le corresponda a un string, es decir, cada struct tiene un campo que se llama vocales y otro que se llama consonantes.
